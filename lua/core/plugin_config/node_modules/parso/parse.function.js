"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const invalid_input_error_1 = require("./errors/invalid-input.error");
const parser_registry_class_1 = require("./parser-registry.class");
/**
 * Tries to parse the recieved value into a `Date` object with the registered parsers,
 * returns null if the parsing attempt fails.
 *
 * @param value any string or number to parse into a Date
 * @param parseOptions
 */
function parse(value, parseOptions = {}) {
    if (value instanceof Date) {
        /** For better developer UX Parso accepts Date objects, but immediatelly returns a clone of them. */
        return new Date(value);
    }
    /** If the recieved value is not string, number or Date, then Parso cannot process it. */
    if (typeof value !== 'string' && typeof value !== 'number') {
        throw new invalid_input_error_1.ParsoInvalidInputError(value);
    }
    /**
     * When `handleNumberAsEpoch` is set to true we treat numbers as millisecond values.
     */
    if (typeof value == 'number' && parseOptions.handleNumberAsEpoch === true) {
        return new Date(value);
    }
    const currentParsers = parseOptions.customRegistry ? parseOptions.customRegistry.parsers : parser_registry_class_1.defaulParserRegistry.parsers;
    const firstWorkingParser = currentParsers.find(parser => parser(value) !== undefined);
    if (firstWorkingParser) {
        return firstWorkingParser(value);
    }
    return null;
}
exports.parse = parse;
//# sourceMappingURL=parse.function.js.map